' A frequency modulation synthesizer/audio driver for a P2
' v. 0.04- 20220712
' MIT license
' Piotr Kardasz pik33@o2.pl with the help from P2 forum community :) 
' 16 channel version
'-------------------------------------------------------------------------------------

'Channel registers:
'                                              			init value
'long #00 00 pointer0  	the sample phase accumulator  		0    
'long #01 04 adcptr 	ADSR phase accumulator       		0
'long #02 08 envstate   ADSR state                   		%0111111111111
'long #03 12 adr1       ADSR rate 1                   		$0800 (TEST) / $2800_0000(MAX)		bit30 note on, bit 31 note off, check on one op only, save!
'long #04 16 adr2       ADSR rate 2 		  		$0800 / $2800_0000
'long #05 20 adr3       ADSR rate 3				$0800 / $2800_0000
'long #06 24 adr4 	ADSR rate 4				$0800 / $2800_0000
'long #07 28 adl1       ADSR level 1                   	 	$7FFF_FFFF		  (MAX)
'long #08 32 adl2       ADSR level 2		        	$77FF_0000 / $7FFF_FFFF
'long #09 36 adl3       ADSR level 3                    	$6FFF_0000 / $7FFF_FFFF
'long #10 40 adl4       ADSR level 4				0
'long #11 44 vol0	channel volume, 0..16384 		0       
'long #12 48 freq   	channel frequency, 52209.06822=1 Hz	0



'------------------------------------------------------------------------------------
'sample rate=82264.7759 at 336_956_522 Hz CPU clock = clock/4096

'' for FM
{{
        we need
        - PA, 96 of them for 16x6 ops
        - ADSR, 2x96 longs 
        - sample values
}}

'-----------------------------------
con

left= 14
right=15
channels=16
var

long channel1[32*16*6]

'------------------- Start the driver --------------------------------------------

pub start() :cog,base 

base:=@channel1[0]
cog:=coginit(16,@audio,base)
waitms(100)
return cog,base

'------------------ PASM driver code --------------------------------------------

dat

audio       	org     0
            	wrpin   dac,#left           
            	wxpin   ##2*4096,#left    	 
            	wrpin   dac,#right
            	wxpin   ##2*4096,#right    
            	dirh    #left addpins 1
            	setse1  #%001<<6 + left      		' Set the event - DAC empty
       

'----------------- The main loop -------------------------------------------------

loop        	mov  	cn,#channels-1              
              	mov  	rs,#0
                        
p401        	getct   t1
                setq    #35                     	' read parameters
            	rdlong  pointer0,ptra

p403	      	bitl    vol0,#30 wcz            	' if bit #30 of start pointer is set, the current pointer needs resetting  
    if_nz       jmp     #p501			 	' there is no note on, skip

        	mov     pointer0, #0                    ' note on
        	mov     adcptr0,a58000000           	' start envelope too /2
        	mov     adcptr1,a58000000           	' start envelope too /2
                mov     awrite,#24

                mov 	envskip0,envskip01
        	mov     envskip1,envskip11
        	debug(udec(adr01,adl01))

p501   	        bitl    vol0,#31 wcz 			' note off
    if_nz	jmp     #p502
                cmp     adl04,adcptr0 wc
    if_c	mov     envskip0,s4d1
    if_nc	mov	envskip0,s4u1         		
                cmp     adl14,adcptr1 wc
    if_c	mov     envskip1,s4d1
    if_nc	mov	envskip1,s4u1        		
       		
                mov 	awrite,#24

p502           	add     pointer0,freq0          	  
            	add	mod0,pointer0 
            	shl     mod0,#4
                qrotate a7fff,mod0        

   	        add     pointer1,freq1          	   
            	add	mod1,pointer1
            	shl     mod1,#4
                qrotate a7fff,mod1
 
             
 '---------
 
'envskip skip patterns
'phase 1 up:    #%1111_11111111_11110010
'phase 1 down:  #%1111_11111111_11101001
'phase 2 up:    #%1111_11111110_01011111
'phase 2 down:  #%1111_11111101_00111111
'phase 3 up:    #%1111_11001011_11111111
'phase 3 down:  #%1111_10100111_11111111
'phase 4 up:    #%1001_01111111_11111111
'phase 4 down:  #%0100_11111111_11111111



  
   
                skipf envskip0
						'1up 1dn 2up 2dn 3up 3dn 4up 4dn  0	

		add 	adcptr0,adr01		' 0   1   1   1	  1   1   1   1   1	
		sub 	adcptr0,adr01 		' 1   0   
		cmp	adcptr0,adl01 wcz	' 0   0
    if_nc	mov     envskip0,envskip02     	' 0   1
    if_c        mov     envskip0,envskip02      	' 1   0
    		add     adcptr0,adr02           ' 1   1   0   1
		sub 	adcptr0,adr02    	' 1   1   1   0
		cmp	adcptr0,adl02 wcz	' 1   1   0   0
    if_nc	mov     envskip0,envskip03		' 1   1   0   1		
    if_c	mov     envskip0,envskip03		' 1   1   1   0
    		add     adcptr0,adr03		' 1   1           0   1
		sub 	adcptr0,adr03		' 1   1           1   0
		cmp	adcptr0,adl03 wcz	' 1   1           0   0
    if_nc	mov     envskip0,s01		' 1   1           0   1
    if_c	mov     envskip0,s01		' 1   1           1   0
    		add     adcptr0,adr04		' 1   1			  0   1 	
		sub 	adcptr0,adr04		' 1   1	                  1   0
		cmp	adcptr0,adl04 wcz	' 1   1                   0   0
    if_nc	mov     envskip0,s01		' 1   1                   0   1 
    if_c	mov     envskip0,s01      	' 1   1                   1   0

               ' 8..12
  
 
                 fle adcptr0,a7FFFFFFF
                 fge adcptr0,a44000000
 
       getqx spl0
 
       
                mov advalue0,adcptr0       
                shl advalue0,#1
       qexp    advalue0             
              getqx spl1 
   
   	     


                skipf envskip1
						'1up 1dn 2up 2dn 3up 3dn 4up 4dn  0	

		add 	adcptr1,adr11		' 0   1   1   1	  1   1   1   1   1	
		sub 	adcptr1,adr11 		' 1   0   
		cmp	adcptr1,adl11 wcz	' 0   0
    if_nc	mov     envskip1,envskip12     	' 0   1
    if_c        mov     envskip1,envskip12      	' 1   0
    		add     adcptr1,adr12           ' 1   1   0   1
		sub 	adcptr1,adr12    	' 1   1   1   0
		cmp	adcptr1,adl12 wcz	' 1   1   0   0
    if_nc	mov     envskip1,envskip13		' 1   1   0   1		
    if_c	mov     envskip1,envskip13		' 1   1   1   0
    		add     adcptr1,adr13		' 1   1           0   1
		sub 	adcptr1,adr13		' 1   1           1   0
		cmp	adcptr1,adl13 wcz	' 1   1           0   0
    if_nc	mov     envskip1,s01		' 1   1           0   1
    if_c	mov     envskip1,s01		' 1   1           1   0
    		add     adcptr1,adr14		' 1   1			  0   1 	
		sub 	adcptr1,adr14		' 1   1	                  1   0
		cmp	adcptr1,adl14 wcz	' 1   1                   0   0
    if_nc	mov     envskip1,s01		' 1   1                   0   1 
    if_c	mov     envskip1,s01      	' 1   1                   1   0

    	     
    	        fle adcptr1,a7FFFFFFF
                fge adcptr1,a44000000
                mov advalue1,adcptr1   
          shl advalue1,#1
         qexp advalue1



        getqx advalue0
    
           
                mov mod0,#0
                mov mod1,#0

        
                shr     advalue0,#18
        	scas    advalue0,vol0
           	scas    spl0,0-0                  	' apply volume
            	mov 	spl0,0-0
            	scas    spl0,m06
            	add     rs,0-0
            	bitnot  spl0,#15
      
         getqx advalue1           
                sca     spl0,m00
                add     mod0,0-0
                sca     spl0,m10
 		add     mod1,0-0
 		
 		
                shr     advalue1,#18
        	scas    advalue1,vol1
            	scas    spl1,0-0                  	' apply volume
            	mov 	spl1,0-0
            	scas 	spl1,m16

            	add     rs,0-0
            	bitnot  spl1,#15

                sca     spl1,m01
                add     mod0,0-0
                sca     spl1,m11
 		add     mod1,0-0 
   
           

          	shl     mod0,#18
          	shl 	mod1,#18
          	
          	
        	setq 	awrite                      	' write new pointer and sample value to the hub
            	wrlong  pointer0,ptra
		mov     awrite,#23
           	add 	ptra,#144   ' next channel
           	
  	
           	
getct   t2
sub t2,t1
wrlong t2,#$70
            	djnf    cn,#p401 

' now all channels processed

		bitl    vol0,#29 wcz			' program change
    if_nz	jmp #p503
    

           	setq	#95
    		rdlong  adr01,ptra
   	        sub     ptra,#48
     		wrlong  vol0,ptra

                cmp     adl01,adl04 wc
    if_c	mov     envskip01,s1d1
    if_nc	mov	envskip01,s1u1    
                cmp     adl02,adl01 wc
    if_c	mov     envskip02,s2d1
    if_nc	mov	envskip02,s2u1    
                cmp     adl03,adl02 wc
    if_c	mov     envskip03,s3d1
    if_nc	mov	envskip03,s3u1   
     
                cmp     adl11,adl14 wc
    if_c	mov     envskip11,s1d1
    if_nc	mov	envskip11,s1u1    
                cmp     adl12,adl11 wc
    if_c	mov     envskip12,s2d1
    if_nc	mov	envskip12,s2u1    
                cmp     adl13,adl12 wc
    if_c	mov     envskip13,s3d1
    if_nc	mov	envskip13,s3u1  

p503	
    if_nz     	sub ptra,#48           
 
 '---------
 
           		' convert to unsigned. 
	   	bitnot  rs,#15		  
 
  		waitse1
            	wypin   rs,#left       		      	' output the sample     
            	wypin   rs,#right         
	        sub 	ptra,aptra
                jmp     #loop            


' temporary variables 

spl0 long 0
spl1 long 0
spl2 long 0
spl3 long 0
spl4 long 0
spl5 long 0


qq          long 0
cn          long 0
pointer00   long 0
ls          long 0    
rs          long 0
advalue0     long 0
advalue1     long 0
advalue2    long 0
advalue3     long 0
advalue4     long 0
advalue5    long 0

' channel parameter block:

'------  Variables different per channel that change everytime. They are kept in HUB and reloaded and saved every new channel 

pointer0    long 0      
adcptr0	    long 0
envskip0    long 0
mod0	    long 0

pointer1    long 0      
adcptr1	    long 0
envskip1    long 0
mod1	    long 0

pointer2    long 0      
adcptr2	    long 0
envskip2    long 0
mod2	    long 0

pointer3    long 0      
adcptr3	    long 0
envskip3    long 0
mod3	    long 0

pointer4    long 0      
adcptr4	    long 0
envskip4    long 0
mod4	    long 0

pointer5    long 0      
adcptr5	    long 0
envskip5    long 0
mod5	    long 0


'------ These variables have to be loaded at note on and not saved except vol0

vol0	  	long 0
freq0		long 0
vol1		long 0
freq1		long 0
vol2 		long 0
freq2		long 0
vol3		long 0
freq3		long 0
vol4		long 0
freq4		long 0
vol5		long 0
freq5		long 0

' ------ These variables are common for all channels to be loaded at sound change, This needs to be additionally triggered.

'---- op 1

adr01        	long 0     
adr02        	long 0
adr03        	long 0
adr04        	long 0

adl01        	long $7FFF_0000
adl02        	long $77FF_0000
adl03       	long $6FFF_0000
adl04        	long $0200_0000

m00      	long 0
m01	        long 0
m02		long 0
m03		long 0
m04		long 0
m05		long 0
m06		long 0
sense0		long 0 

'---- op 2
 
adr11        	long 0      
adr12        	long 0
adr13        	long 0
adr14        	long 0

adl11        	long $7FFF_0000
adl12        	long $77FF_0000
adl13        	long $6FFF_0000
adl14        	long $0200_0000

m10		long 0
m11      	long 0
m12	        long 0
m13		long 0
m14		long 0
m15		long 0
m16		long 0
sense1		long 0  

adr21        	long 0      
adr22        	long 0
adr23        	long 0
adr24        	long 0

adl21        	long $7FFF_0000
adl22        	long $77FF_0000
adl23        	long $6FFF_0000
adl24        	long $0200_0000

m20		long 0
m21      	long 0
m22	        long 0
m23		long 0
m24		long 0
m25		long 0
m26		long 0
sense2		long 0 

adr31        	long 0     ' start pointer and type at bit 31
adr32        	long 0
adr33        	long 0
adr34        	long 0

adl31        	long $7FFF_0000
adl32        	long $77FF_0000
adl33        	long $6FFF_0000
adl34        	long $0200_0000

m30		long 0
m31      	long 0
m32	        long 0
m33		long 0
m34		long 0
m35		long 0
m36		long 0
sense3		long 0 

adr41        long 0     ' start pointer and type at bit 31
adr42        long 0
adr43        long 0
adr44        long 0

adl41        long $7FFF_0000
adl42        long $77FF_0000
adl43        long $6FFF_0000
adl44        long $0200_0000

m40		long 0
m41      	long 0
m42	        long 0
m43		long 0
m44		long 0
m45		long 0
m46		long 0
sense4		long 0 

adr51        long 0     ' start pointer and type at bit 31
adr52        long 0
adr53        long 0
adr54        long 0

adl51        long $7FFF_0000
adl52        long $77FF_0000
adl53        long $6FFF_0000
adl54        long $0200_0000

m50		long 0
m51      	long 0
m52	        long 0
m53		long 0
m54		long 0
m55		long 0
m56		long 0
sense5		long 0 

envskip     long 0

envskip01 long 0
envskip02 long 0
envskip03 long 0
envskip04 long 0

envskip11 long 0
envskip12 long 0
envskip13 long 0
envskip14 long 0

envskip21 long 0
envskip22 long 0
envskip23 long 0
envskip24 long 0

envskip31 long 0
envskip32 long 0
envskip33 long 0
envskip34 long 0

envskip41 long 0
envskip42 long 0
envskip43 long 0
envskip44 long 0

envskip51 long 0
envskip52 long 0
envskip53 long 0
envskip54 long 0

pan0        long 0 ' only output


' constants

dac         	long 	%10111_00000000_01_00011_0     'pwm dac
affffffff   	long 	$FFFF_FFFF   
a7fffffff   	long 	$7FFF_FFFF   
aptra	    	long 	144*channels-48
a7fff     long $7fff
affff     long $ffff

t1 long 0
t2 long 0

s1u 		long  %1111__0_1111111_0_1_111100_0_10
s1d 		long  %1111__0_1111111_0_1_111010_0_01
s2u		long  %1111__0_1111111_0_0_010111_0_11
s2d		long  %1111__0_1111110_0_1_001111_0_11
s3u		long  %1111__0_1100101_0_1_111111_0_11
s3d		long  %1111__0_1010011_0_1_111111_0_11
s4u		long  %1001__0_0111111_0_1_111111_0_11
s4d		long  %0100__0_1111111_0_1_111111_0_11
s0		long  %1111__0_1111111_0_1_111111_0_11

s1u1 		long  %1111_11111111_11110010
s1d1 		long  %1111_11111111_11101001
s2u1		long  %1111_11111110_01011111
s2d1		long  %1111_11111101_00111111
s3u1		long  %1111_11001011_11111111
s3d1		long  %1111_10100111_11111111
s4u1		long  %1001_01111111_11111111
s4d1		long  %0100_11111111_11111111
s01		long  %1111_11111111_11111111



awrite      long 23

a58000000 long $5800_0000 
a44000000 long $4400_0000
fit 400


{{
        
        Variables for ALL channels  operator specific (x6) that changes only when sound definition change:
        -r1,r2,r3,r4,l1,l2,l3,l4, feedback , mod sense. These are 60 longs = 10 var*6 op
        
        Variables different per channel that change on note on 
        - volume, frequency, trigger at Op 1, that are 192 longs
        
        Variables in main cog
        split breakpoint,key velocity, main level
        
         Variables different per channel that change everytime     
        -pointer, adcptr, envstate, mod input, that are 384 longs  

}}
