' A midi cog
' The purpose: to read and process data from a Midi Shield
' v. 0.01 pik33@o2.pl
'
con

midiin=29
midiout=30
mbaudrate=31250

var

long midifront,miditail
long midibuf[512]
long serialstack[64]

'--------------------------------------------------------------
pub dummy()

repeat
'this is the object and not a program

'--------------------------------------------------------------

pub start() :cog
debug(udec(1))
cog:=cogspin(16,serialcog(),@serialstack)
return cog

'--------------------------------------------------------------

pub readmidi:midi |result

if midifront<>miditail
  result:=midibuf[miditail]
  miditail++
  miditail:= miditail // 512
else
  result:=0  
return result

'--------------------------------------------------------------

pub serialcog()| rr, mrr, srr, b, mb, midireport

'start midi

serial_start(midiin,midiout,mbaudrate)
mb:=(-1)
b:=(-1)
midifront:=0
miditail:=0

repeat
  mrr:=rxcheck(midiin)
  
' midi. Must be >= $80 for a command
'$80-$8F - 3 bytes note off. note, velocity
'$90-$9F - 3 bytes note on, note, velocity
'$A0-$AF - 3 bytes poly aftertouch. note, value
'$B0-$BF - 3 bytes control change, controller-value, 
'$C0-$CF - 2 bytes program change
'$D0-$DF - 2 bytes mono aftertouch
'$E0-$EF - 3 bytes pitch bend, $2000 - center
'$F0-$FF - 1 byte
  
  
  if ((mrr>=$80) && (mrr<=$BF)) || ((mrr>=$E0) && (mrr<=$EF)) 
    mb:=2
    midireport:=mrr<<24

  if (mrr>=$C0) && (mrr<=$DF)
    mb:=1
    midireport:=mrr<<24
  
  if (mrr>=$F0) 'TODO: do something with SYSEX, now a workaround for Novation Impulse
    mb:=4
    midireport:=mrr<<24  
  
  if (mrr<$80) && (mb>0) && (mrr>=0)
    mb--
    if mb<3
      midireport+=mrr<<(mb<<3)
  
  if mb==0
    if midifront<>((miditail-1) //512)
      midibuf[midifront]:=midireport
      midifront+=1
      midifront:=midifront // 512
    mb:=(-1)

''---------------------- Serial functions from jm_serial.spin2, modified

pub serial_start(rxpin, txpin, baud) | bitmode

bitmode := muldiv64(clkfreq, $1_0000, baud) & $FFFFFC00       ' set bit timing
bitmode |= 7                                                  ' set bits (8)
pinstart(rxpin,P_HIGH_15K|P_ASYNC_RX,bitmode,0)
pinstart(txpin,P_ASYNC_TX|P_OE,bitmode,0)
pinhigh(rxpin)

pub rxcheck(pin) : rxbyte | check

'' Check for serial input
'' -- returns -1 if nothing available

  rxbyte := -1
  check := pinr(pin)
  if (check)
    rxbyte := rdpin(pin) >> 24

pub tx(pin,b)

'' Emit byte

  wypin(pin, b)
  txflush(pin)

pub txflush(pin) | check

'' Wait until last byte has finished

  repeat
    check := pinr(pin)
  while (check == 0)
