' A frequency modulation synthesizer/audio driver for a P2
' v. 0.04- 20220712
' MIT license
' Piotr Kardasz pik33@o2.pl with the help from P2 forum community :) 
' 16 channel version
'-------------------------------------------------------------------------------------

'Channel registers:
'                                              			init value
'long #00 00 pointer0  	the sample phase accumulator  		0    
'long #01 04 adcptr 	ADSR phase accumulator       		0
'long #02 08 envstate   ADSR state                   		%0111111111111
'long #03 12 adr1       ADSR rate 1                   		$0800 (TEST) / $2800_0000(MAX)		bit30 note on, bit 31 note off, check on one op only, save!
'long #04 16 adr2       ADSR rate 2 		  		$0800 / $2800_0000
'long #05 20 adr3       ADSR rate 3				$0800 / $2800_0000
'long #06 24 adr4 	ADSR rate 4				$0800 / $2800_0000
'long #07 28 adl1       ADSR level 1                   	 	$7FFF_FFFF		  (MAX)
'long #08 32 adl2       ADSR level 2		        	$77FF_0000 / $7FFF_FFFF
'long #09 36 adl3       ADSR level 3                    	$6FFF_0000 / $7FFF_FFFF
'long #10 40 adl4       ADSR level 4				0
'long #11 44 vol0	channel volume, 0..16384 		0       
'long #12 48 freq   	channel frequency, 52209.06822=1 Hz	0



'------------------------------------------------------------------------------------
'sample rate=82264.7759 at 336_956_522 Hz CPU clock = clock/4096

'' for FM
{{
        we need
        - PA, 96 of them for 16x6 ops
        - ADSR, 2x96 longs 
        - sample values
}}

'-----------------------------------
con

left= 14
right=15
channels=16
var

long channel1[32*16*6]

'------------------- Start the driver --------------------------------------------

pub start() :cog,base 

base:=@channel1[0]
cog:=coginit(16,@audio,base)
waitms(100)
return cog,base

'------------------ PASM driver code --------------------------------------------

dat

audio       	org     0
            	wrpin   dac,#left           
            	wxpin   ##2*4096,#left    	 
            	wrpin   dac,#right
            	wxpin   ##2*4096,#right    
            	dirh    #left addpins 1
            	setse1  #%001<<6 + left      		' Set the event - DAC empty
       

'----------------- The main loop -------------------------------------------------

loop        	mov  	cn,#channels-1              
              	mov  	rs,#0
                        
p401        	getct   t1
                setq    #35                     	' read parameters
            	rdlong  pointer0,ptra

p403	      	bitl    vol0,#30 wcz            	' if bit #30 of start pointer is set, the current pointer needs resetting  
    if_nz       jmp     #p501			 	' there is no note on, skip

        	mov     pointer0, #0                    ' note on
        	mov     adcptr0,a58000000           	' start envelope too /2
        	mov     adcptr1,a58000000           	' start envelope too /2
        	mov     adcptr2,a58000000           	' start envelope too /2
        	mov     adcptr3,a58000000           	' start envelope too /2
        	mov     adcptr4,a58000000           	' start envelope too /2
        	mov     adcptr5,a58000000           	' start envelope too /2
                mov     awrite,#24
        	mov     env0,envstate1
        	mov     env1,envstate1
        	mov     env2,envstate1
        	mov     env3,envstate1
        	mov     env4,envstate1
        	mov     env5,envstate1

p501   	        bitl    vol0,#31 wcz 			' note off
    if_nz	jmp     #p502
        	mov     env0,envstate4
       		mov     env1,envstate4
       		mov     env2,envstate4
       		mov     env3,envstate4
       		mov     env4,envstate4
       		mov     env5,envstate4
                cmp     adl04,adcptr0 wc
    if_c	mov     envskip04,s4d
    if_nc	mov	envskip04,s4u         		
                cmp     adl14,adcptr1 wc
    if_c	mov     envskip14,s4d
    if_nc	mov	envskip14,s4u         		
                cmp     adl24,adcptr2 wc
    if_c	mov     envskip24,s4d
    if_nc	mov	envskip24,s4u         		
                cmp     adl34,adcptr3 wc
    if_c	mov     envskip34,s4d
    if_nc	mov	envskip34,s4u         		
                cmp     adl44,adcptr4 wc
    if_c	mov     envskip44,s4d
    if_nc	mov	envskip44,s4u         		
                cmp     adl54,adcptr5 wc
    if_c	mov     envskip54,s4d
    if_nc	mov	envskip54,s4u         		
       		
                mov 	awrite,#24

p502           	add     pointer0,freq0          	  
            	add	mod0,pointer0 
            	shl     mod0,#4

                qrotate a7fff,mod0        
   	        add     pointer1,freq1          	   
            	add	mod1,pointer1
            	shl     mod1,#4
                qrotate a7fff,mod1
            	   
         	add     pointer2,freq2          	  
            	add	mod2,pointer2
            	shl     mod2,#4
                qrotate a7fff,mod2   '             

           	add     pointer3,freq3          	  
            	add	mod3,pointer3 
            	shl     mod3,#4
                qrotate a7fff,mod3    '    
  
         	add     pointer4,freq4          	   
            	add	mod4,pointer4 
            	shl     mod4,#4
                qrotate a7fff,mod4             
                
          	add     pointer5,freq5          	  
            	add	mod5,pointer5
            	shl     mod5,#4
                qrotate a7fff,mod5   ''40!
 
	
             
 '---------
 
 


'envelope states = skip patterns

'1: %1111111111000    
'2: %1111111000111
'3: %1111000111111
'4: %1000111111111
'0: %0111111111111

'envskip skip patterns
'phase 1 up:    #%1111_11111111_1 0 1110010
'phase 1 down:  #%1111_11111111_1 0 1101001
'phase 2 up:    #%1111_11111110_0 0 1011111
'phase 2 down:  #%1111_11111101_0 0 0111111
'phase 3 up:    #%1111_11001011_1 0 1111111
'phase 3 down:  #%1111_10100111_1 0 1111111
'phase 4 up:    #%1001_01111111_1 0 1111111
'phase 4 down:  #%0100_11111111_1 0 1111111



                skipf   env0
                
                cmp     adl01,adl04 wc
    if_c	mov     envskip,s1d
    if_nc	mov	envskip,s1u    
                cmp     adl02,adl01 wc
    if_c	mov     envskip,s2d
    if_nc	mov	envskip,s2u    
                cmp     adl03,adl02 wc
    if_c	mov     envskip,s3d
    if_nc	mov	envskip,s3u    
                cmp     adl04,adcptr0 wc
    if_c	mov     envskip,s4d
    if_nc	mov	envskip,s4u  
    		mov 	envskip,s0  '8..12

                getqx spl0
 
 'now we have only 3 ops to get the next result

 



       


                skipf envskip
						'1up 1dn 2up 2dn 3up 3dn 4up 4dn  0	

		add 	adcptr0,adr01		' 0   1   1   1	  1   1   1   1   1	
		sub 	adcptr0,adr01 		' 1   0   
		
                getqx spl1	
		
		cmp	adcptr0,adl01 wcz	' 0   0
    if_nc	mov     env0,envstate2      	' 0   1
    if_c        mov     env0,envstate2      	' 1   0
    		add     adcptr0,adr02           ' 1   1   0   1
		sub 	adcptr0,adr02    	' 1   1   1   0
		cmp	adcptr0,adl02 wcz	' 1   1   0   0
    if_nc	mov     env0,envstate3		' 1   1   0   1		

		getqx spl2			'we have to add this getqx here so the 8th instruction is not skipped
		

    if_c	mov     env0,envstate3		' 1   1   1   0
    		add     adcptr0,adr03		' 1   1           0   1
		sub 	adcptr0,adr03		' 1   1           1   0
		cmp	adcptr0,adl03 wcz	' 1   1           0   0
    if_nc	mov     env0,envstate0		' 1   1           0   1
    if_c	mov     env0,envstate0		' 1   1           1   0
    		add     adcptr0,adr04		' 1   1			  0   1 	
    		          
    		getqx spl3          
    		                                               
		sub 	adcptr0,adr04		' 1   1	                  1   0
		cmp	adcptr0,adl04 wcz	' 1   1                   0   0
    if_nc	mov     env0,envstate0		' 1   1                   0   1 
    if_c	mov     env0,envstate0      	' 1   1                   1   0

               ' 8..12

                getqx spl4

                fle adcptr0,a7FFFFFFF
                fge adcptr0,a44000000
                mov advalue,adcptr0        

                getqx spl5
         
                shl advalue,#1
                
                 
                qexp    advalue
                
                skipf   env1 ' this is per op, do this 5 more time, then teh second skip is 8..12 so qexp every 16, after 3rd get 1st result
                
                cmp     adl11,adl14 wc
    if_c	mov     envskip,s1d1
    if_nc	mov	envskip,s1u1    
                cmp     adl12,adl11 wc
    if_c	mov     envskip,s2d1
    if_nc	mov	envskip,s2u1    
                cmp     adl13,adl12 wc
    if_c	mov     envskip,s3d1
    if_nc	mov	envskip,s3u1    
                cmp     adl14,adcptr1 wc
    if_c	mov     envskip,s4d1
    if_nc	mov	envskip,s4u1    
    		mov 	envskip,s01

  
                skipf envskip
						'1up 1dn 2up 2dn 3up 3dn 4up 4dn  0	

		add 	adcptr1,adr11		' 0   1   1   1	  1   1   1   1   1	
		sub 	adcptr1,adr11 		' 1   0   
'		nop
		cmp	adcptr1,adl11 wcz	' 0   0
    if_nc	mov     env1,envstate2      	' 0   1
    if_c        mov     env1,envstate2      	' 1   0
    		add     adcptr1,adr12           ' 1   1   0   1
		sub 	adcptr1,adr12    	' 1   1   1   0
		cmp	adcptr1,adl12 wcz	' 1   1   0   0
		
    if_nc	mov     env1,envstate3		' 1   1   0   1
 '               nop 
    if_c	mov     env1,envstate3		' 1   1   1   0
    		add     adcptr1,adr13		' 1   1           0   1
		sub 	adcptr1,adr13		' 1   1           1   0
		cmp	adcptr1,adl13 wcz	' 1   1           0   0
    if_nc	mov     env1,envstate0		' 1   1           0   1
    if_c	mov     env1,envstate0		' 1   1           1   0
    		add     adcptr1,adr14		' 1   1			  0   1 	
  '  		nop                                               
		sub 	adcptr1,adr14		' 1   1	                  1   0
		cmp	adcptr1,adl14 wcz	' 1   1                   0   0
    if_nc	mov     env1,envstate0		' 1   1                   0   1 
    if_c	mov     env1,envstate0      	' 1   1                   1   0

                fle adcptr1,a7FFFFFFF
                fge adcptr1,a44000000
                mov advalue,adcptr1
                shl advalue,#1                
                
                
                
                
                

      '          and     spl0,affff

                getqx   advalue
                shr     advalue,#18
        	scas    advalue,vol0
            	scas    spl0,0-0                  	' apply volume
            	mov 	spl0,0-0
            	add     rs,spl0
            	bitnot  spl0,#15
                mul     spl0,feedback0
                
                mov     mod0,spl0
          	shl     mod0,#2
        	setq 	awrite                      	' write new pointer and sample value to the hub
            	wrlong  pointer0,ptra
		mov     awrite,#23
           	add 	ptra,#144   ' next channel
getct   t2
sub t2,t1
wrlong t2,#$70
            	djnf    cn,#p401 

' now all channels processed

		bitl    vol0,#29 wcz			' program change
    if_nz	jmp #p503
           	setq	#59
    		rdlong  adr01,ptra
   	        sub     ptra,#48
     		wrlong  vol0,ptra

                cmp     adl01,adl04 wc
    if_c	mov     envskip01,s1d
    if_nc	mov	envskip01,s1u    
                cmp     adl02,adl01 wc
    if_c	mov     envskip02,s2d
    if_nc	mov	envskip02,s2u    
                cmp     adl03,adl02 wc
    if_c	mov     envskip03,s3d
    if_nc	mov	envskip03,s3u   
     
                cmp     adl11,adl14 wc
    if_c	mov     envskip11,s1d
    if_nc	mov	envskip11,s1u    
                cmp     adl12,adl11 wc
    if_c	mov     envskip12,s2d
    if_nc	mov	envskip12,s2u    
                cmp     adl13,adl12 wc
    if_c	mov     envskip13,s3d
    if_nc	mov	envskip13,s3u  
      
                cmp     adl21,adl24 wc
    if_c	mov     envskip21,s1d
    if_nc	mov	envskip21,s1u    
                cmp     adl22,adl21 wc
    if_c	mov     envskip22,s2d
    if_nc	mov	envskip22,s2u    
                cmp     adl23,adl22 wc
    if_c	mov     envskip23,s3d
    if_nc	mov	envskip23,s3u   
     
                cmp     adl31,adl34 wc
    if_c	mov     envskip31,s1d
    if_nc	mov	envskip31,s1u    
                cmp     adl32,adl31 wc
    if_c	mov     envskip32,s2d
    if_nc	mov	envskip32,s2u    
                cmp     adl33,adl32 wc
    if_c	mov     envskip33,s3d
    if_nc	mov	envskip33,s3u   
     
                cmp     adl41,adl44 wc
    if_c	mov     envskip41,s1d
    if_nc	mov	envskip41,s1u    
                cmp     adl42,adl41 wc
    if_c	mov     envskip42,s2d
    if_nc	mov	envskip42,s2u    
                cmp     adl43,adl42 wc
    if_c	mov     envskip43,s3d
    if_nc	mov	envskip43,s3u    

                cmp     adl51,adl54 wc
    if_c	mov     envskip51,s1d
    if_nc	mov	envskip51,s1u    
                cmp     adl52,adl51 wc
    if_c	mov     envskip52,s2d
    if_nc	mov	envskip52,s2u    
                cmp     adl53,adl52 wc
    if_c	mov     envskip53,s3d
    if_nc	mov	envskip53,s3u    

 
p503	
    if_nz     	sub ptra,#48           
 
 '---------
 
           		' convert to unsigned. 
	   	bitnot  rs,#15		  
 
  		waitse1
            	wypin   rs,#left       		      	' output the sample     
            	wypin   rs,#right         
	        sub 	ptra,aptra
                jmp     #loop            


' temporary variables 

spl0 long 0
spl1 long 0
spl2 long 0
spl3 long 0
spl4 long 0
spl5 long 0


qq          long 0
cn          long 0
pointer00   long 0
ls          long 0    
rs          long 0
advalue     long 0

' channel parameter block:

'------  Variables different per channel that change everytime. They are kept in HUB and reloaded and saved every new channel 

pointer0    long 0      
adcptr0	    long 0
env0        long 0
mod0	    long 0

pointer1    long 0      
adcptr1	    long 0
env1        long 0
mod1	    long 0

pointer2    long 0      
adcptr2	    long 0
env2        long 0
mod2	    long 0

pointer3    long 0      
adcptr3	    long 0
env3        long 0
mod3	    long 0

pointer4    long 0      
adcptr4	    long 0
env4        long 0
mod4	    long 0

pointer5    long 0      
adcptr5	    long 0
env5        long 0
mod5	    long 0


'------ These variables have to be loaded at note on and not saved except vol0

vol0	  	long 0
freq0		long 0
vol1		long 0
freq1		long 0
vol2 		long 0
freq2		long 0
vol3		long 0
freq3		long 0
vol4		long 0
freq4		long 0
vol5		long 0
freq5		long 0

' ------ These variables are common for all channels to be loaded at sound change, This needs to be additionally triggered.

'---- op 1

adr01        	long 0     
adr02        	long 0
adr03        	long 0
adr04        	long 0

adl01        	long $7FFF_0000
adl02        	long $77FF_0000
adl03       	long $6FFF_0000
adl04        	long $0200_0000

feedback0    	long 127
sense0		long 0 

'---- op 2
 
adr11        	long 0      
adr12        	long 0
adr13        	long 0
adr14        	long 0

adl11        	long $7FFF_0000
adl12        	long $77FF_0000
adl13        	long $6FFF_0000
adl14        	long $0200_0000

feedback1   	long 0
sense1		long 0 

adr21        	long 0      
adr22        	long 0
adr23        	long 0
adr24        	long 0

adl21        	long $7FFF_0000
adl22        	long $77FF_0000
adl23        	long $6FFF_0000
adl24        	long $0200_0000

feedback2 	long 0
sense2 		long 0

adr31        	long 0     ' start pointer and type at bit 31
adr32        	long 0
adr33        	long 0
adr34        	long 0

adl31        	long $7FFF_0000
adl32        	long $77FF_0000
adl33        	long $6FFF_0000
adl34        	long $0200_0000

feedback3 	long 0
sense3 		long 0

adr41        long 0     ' start pointer and type at bit 31
adr42        long 0
adr43        long 0
adr44        long 0

adl41        long $7FFF_0000
adl42        long $77FF_0000
adl43        long $6FFF_0000
adl44        long $0200_0000

feedback4 	long 0
sense4 		long 0

adr51        long 0     ' start pointer and type at bit 31
adr52        long 0
adr53        long 0
adr54        long 0

adl51        long $7FFF_0000
adl52        long $77FF_0000
adl53        long $6FFF_0000
adl54        long $0200_0000

feedback5 	long 0
sense5 		long 0


envskip     long 0

envskip01 long 0
envskip02 long 0
envskip03 long 0
envskip04 long 0

envskip11 long 0
envskip12 long 0
envskip13 long 0
envskip14 long 0

envskip21 long 0
envskip22 long 0
envskip23 long 0
envskip24 long 0

envskip31 long 0
envskip32 long 0
envskip33 long 0
envskip34 long 0

envskip41 long 0
envskip42 long 0
envskip43 long 0
envskip44 long 0

envskip51 long 0
envskip52 long 0
envskip53 long 0
envskip54 long 0

pan0        long 0 ' only output


' constants

dac         	long 	%10111_00000000_01_00011_0     'pwm dac
affffffff   	long 	$FFFF_FFFF   
a7fffffff   	long 	$7FFF_FFFF   
aptra	    	long 	144*channels-48
a7fff     long $7fff
affff     long $ffff

t1 long 0
t2 long 0

s1u 		long  %1111__0_1111111_0_1_111100_0_10
s1d 		long  %1111__0_1111111_0_1_111010_0_01
s2u		long  %1111__0_1111111_0_0_010111_0_11
s2d		long  %1111__0_1111110_0_1_001111_0_11
s3u		long  %1111__0_1100101_0_1_111111_0_11
s3d		long  %1111__0_1010011_0_1_111111_0_11
s4u		long  %1001__0_0111111_0_1_111111_0_11
s4d		long  %0100__0_1111111_0_1_111111_0_11
s0		long  %1111__0_1111111_0_1_111111_0_11

s1u1 		long  %1111_11111111_11110010
s1d1 		long  %1111_11111111_11101001
s2u1		long  %1111_11111110_01011111
s2d1		long  %1111_11111101_00111111
s3u1		long  %1111_11001011_11111111
s3d1		long  %1111_10100111_11111111
s4u1		long  %1001_01111111_11111111
s4d1		long  %0100_11111111_11111111
s01		long  %1111_11111111_11111111

envstate1	long  %1111111111000   
envstate2	long  %1111111000111
envstate3	long  %1111000111111
envstate4	long  %1000111111111
envstate0	long  %0111111111111

awrite      long 23

a58000000 long $5800_0000 
a44000000 long $4400_0000
fit 450


{{
        
        Variables for ALL channels  operator specific (x6) that changes only when sound definition change:
        -r1,r2,r3,r4,l1,l2,l3,l4, feedback , mod sense. These are 60 longs = 10 var*6 op
        
        Variables different per channel that change on note on 
        - volume, frequency, trigger at Op 1, that are 192 longs
        
        Variables in main cog
        split breakpoint,key velocity, main level
        
         Variables different per channel that change everytime     
        -pointer, adcptr, envstate, mod input, that are 384 longs  

}}
